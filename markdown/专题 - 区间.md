##### 区间问题

|[区间合并](/acwing/Section%201/acwing%20-%20%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6.md)|区间覆盖|区间交集|区间不相交选择|
|  :-:  |  :-:  |  :-:  |  :-:  |
|[56. 合并区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4.md#lc56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4)|[55. 跳跃游戏](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.md#lc55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F)|[986. 区间列表的交集](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4.md#lc986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86)|[435. 无重叠区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%80%89%E6%8B%A9.md#lc435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4)|
|[57. 插入区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4.md#lc57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4)|[45. 跳跃游戏Ⅱ](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.md#lc45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%B1)|       |        |
|       |[763. 划分字母区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.md#lc763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4)|       |         |
|       |[1024. 视频拼接](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.md#lc1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5)|     |       |
|       |[1326. 灌溉花园的最少水龙头数目](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.md#lc1326-%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4%E6%95%B0%E7%9B%AE)|       |     |


###### [LC56. 合并区间](/workspace/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp)

https://leetcode.cn/problems/merge-intervals

###### [LC57. 插入区间](/workspace/57.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4.cpp)

```CPP
// 从开始早的开始, 扩散cover范围
bool static cmp(vector<int> l, vector<int> r){
    // 其实没必要
    if(l[0]==r[0])
        return l[1] < r[1];
    return l[0] < r[0];
}
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    vector<vector<int> > ans;
    int start = intervals[0][0];
    int end = intervals[0][1];
    for(int i=1; i<intervals.size(); i++){
        // 可以合并
        if(intervals[i][0] <= end){
            end = max(end, intervals[i][1]);
        }
        // 不可以合并
        else{
            // 保存之前的合并结果
            ans.push_back({start, end});
            // 更新start, end
            start = intervals[i][0];
            end = intervals[i][1];
        }
    }
    // last one
    ans.push_back({start, end});
    return ans;
}
```


###### [LC452. 用最少数量的箭引爆气球](/workspace/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.cpp)

> 与[LC435. 无重叠区间](/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4%20-%20%E5%8C%BA%E9%97%B4%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%80%89%E6%8B%A9.md#lc435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4)类似, 都是**按右端点排序**
> 
> 尽量都用points[0][1]来初始化, 而不是`INT_MIN`, 而不是0
> 
> 比如本题的测试用例`[[-2147483648,2147483647]]`, `points[0][0]==INT_MIN`

```CPP
// 按右边界排序
bool static cmp(vector<int> &l, vector<int> &r){
    return l[1] < r[1];
}
int findMinArrowShots(vector<vector<int>>& points) {
    sort(points.begin(), points.end(), cmp);
    int end = points[0][1];
    int cnt = 1;
    for(int i=0; i<points.size(); i++){
        if(points[i][0] > end){
            end = points[i][1];
            cnt++;
        }
    }
    return cnt;
}
```

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/'


###### [LC406. 根据身高重建队列](/markdown/LC406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.md)

> 方法一: 从低到高排序, 相等则先排k小的; 每次放入前数空格位置(高度相等也计一个空格)
>
> 方法二: 先放高的, 直接放在k位置, 如果高度相同先放k小的; 维护一个queue或者vector, 借助`vi.insert(it, val)`方法插入到指定位置后
> 
> 等等, 这题怎么是区间呢...

https://leetcode.cn/problems/queue-reconstruction-by-height/


###### [LC986. 区间列表的交集](/workspace/986.%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86.cpp)

> 两个分别不相交的、排好序的interval列表, 不是单纯求所有intervals的交集
> 
> 两个指针`fIndex`和`sIndex`用于遍历两个list
> 
> 在至少一个列表不为空的情况下: 
> 
> => 如果不相交, 调整`fIndex`和`sIndex`
> 
> => 如果相交, 分情况保存相交部分, 并调整`fIndex`或`sIndex`

```CPP
vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
    vector<vector<int>> ans;
    // 两个指针遍历first和second两个internal列表
    int fIndex = 0;
    int sIndex = 0;
    while(fIndex < firstList.size() && sIndex < secondList.size()){
        int fl = firstList[fIndex][0];
        int fr = firstList[fIndex][1];
        int sl = secondList[sIndex][0];
        int sr = secondList[sIndex][1];
        // 不相交, 调整列表指针
        if(fl > sr){
            sIndex++;
            continue;
        }
        if(sl > fr){
            fIndex++;
            continue;
        }
        // 相交 (4种情况), 先想好怎么划分情况更少, 别漏掉
        // 边界相等时怎么处理都可以, 但是需要处理, 不然循环没法继续
        if(fl <= sl && fr <= sr){
            ans.push_back({sl, fr});
            fIndex++;
        }
        else if(fl <= sl && fr >= sr){
            ans.push_back({sl, sr});
            sIndex++;
        }
        else if(fl >= sl && fr >= sr){
            ans.push_back({fl, sr});
            sIndex++;
        }
        else if(fl >= sl && fr <= sr){
            ans.push_back({fl, fr});
            fIndex++;
        }
    }
    return ans;
}
```

https://leetcode.cn/problems/interval-list-intersections/