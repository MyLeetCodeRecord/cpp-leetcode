##### 区间问题

|区间合并|区间覆盖|区间交集|
|  :-:  |  :-:  |  :-:  |
|[56. 合并区间]()|[55. 跳跃游戏]()|[986. 区间列表的交集]()|
|[57. 插入区间]()|[45. 跳跃游戏Ⅱ]()|       |
|       |[763. 划分字母区间]()|       |
|       |[1024. 视频拼接]()||

###### [LC56. 合并区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp)
###### [LC57. 插入区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/57.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4.cpp)
```CPP
// 从开始早的开始, 扩散cover范围
bool static cmp(vector<int> l, vector<int> r){
    // 其实没必要
    if(l[0]==r[0])
        return l[1] < r[1];
    return l[0] < r[0];
}
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    vector<vector<int> > ans;
    int start = intervals[0][0];
    int end = intervals[0][1];
    for(int i=1; i<intervals.size(); i++){
        // 可以合并
        if(intervals[i][0] <= end){
            end = max(end, intervals[i][1]);
        }
        // 不可以合并
        else{
            // 保存之前的合并结果
            ans.push_back({start, end});
            // 更新start, end
            start = intervals[i][0];
            end = intervals[i][1];
        }
    }
    // last one
    ans.push_back({start, end});
    return ans;
}
```


###### [LC435. 无重叠区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.cpp)

> 在每次选择中，选择的区间结束越早，留给后面的区间的空间越大
> 
> 因此按结束时间排序, 如果当前区间`start` >= 上一个采用区间的`end`, 则可以保留, 并更新`end`

```CPP
// 按结束时间排序 (说了八百回, 不加引用超时
bool static cmp(vector<int>& l, vector<int>& r){
    return l[1]<r[1];
}
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    int end = INT_MIN;
    int cnt = 0;
    for(int i=0; i<intervals.size(); i++){
        if(intervals[i][0] >= end){
            cnt++;
            end = intervals[i][1];
        }
    }
    return intervals.size() - cnt;
}
```

https://leetcode.cn/problems/non-overlapping-intervals/



###### [LC452. 用最少数量的箭引爆气球](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.cpp)
> 与[LC435. 无重叠区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4.md#lc435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4)类似, 都是**按右端点排序**
> 
> 尽量都用points[0][1]来初始化, 而不是`INT_MIN`, 而不是0
> 
> 比如本题的测试用例`[[-2147483648,2147483647]]`, `points[0][0]==INT_MIN`
```CPP
// 按右边界排序
bool static cmp(vector<int> &l, vector<int> &r){
    return l[1] < r[1];
}
int findMinArrowShots(vector<vector<int>>& points) {
    sort(points.begin(), points.end(), cmp);
    int end = points[0][1];
    int cnt = 1;
    for(int i=0; i<points.size(); i++){
        if(points[i][0] > end){
            end = points[i][1];
            cnt++;
        }
    }
    return cnt;
}
```

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/'



###### [LC406. 根据身高重建队列](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/LC406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.md)

> 方法一: 从低到高排序, 相等则先排k小的; 每次放入前数空格位置(高度相等也计一个空格)
>
> 方法二: 先放高的, 直接放在k位置, 如果高度相同先放k小的; 维护一个queue或者vector, 借助`vi.insert(it, val)`方法插入到指定位置后
> 
> 等等, 这题怎么是区间呢...

https://leetcode.cn/problems/queue-reconstruction-by-height/



###### [LC986. 区间列表的交集]()
