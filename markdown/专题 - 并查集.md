#### 并查集

##### 实现
> 实现`init`, `union_2`, `find`, `isSame`方法
> 
> - `init()`: father[i]设为i本身, 每个集合的size=1
> - `find(U)`: 一直追溯father, 直到`x==father[x]`到达最高祖先
> - `union_2(U, V)`: 将U's最高祖先的father[find(u)]设为V's最高祖先, 将sizeList[V's最早祖先]+=sizeList[U's最早祖先]
> - `isSame(U,V)`: 追溯各自的最高祖先, 如果相同则U和V处于同一个集合中

```CPP
class UnionFindSet {
    vector<int> father;
    vector<int> sizeList;
public:
    void init_us(int n){
        father.resize(n);
        sizeList.resize(n);
        for(int i=0; i<n; i++){
            father[i] = i;
            sizeList[i] = 1;
        }
    }
    int find(int u){
        return (u==father[u]) ? u : find(father[u]);
    }
    void union_2(int u, int v){
        int pu = find(u);
        int pv = find(v);
        if(pu==pv)
            return ;
        sizeList[pv] += sizeList[pu];
        father[pu] = pv;
    }
    bool isSame(int u, int v){
        return find(u)==find(v);
    }
};
```

##### [LC684. 冗余连接](/workspace/684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.cpp)
> 题目描述: 
> 
>从前向后遍历每一条边，边的两个节点如果最高祖先节点不同(不在同一个集合), 就加入集合
>
> 如果当前边的两个节点最高祖先节点相同(已经出现在同一个集合), 就说明这条边是多余的

> [LC685. 冗余连接Ⅱ](/workspace/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-ii.cpp)是这道题的有向图版本
> 
> 题目描述: https://leetcode.cn/problems/redundant-connection-ii/
> 
> 先检查`indegree=2`的点, 必然有一条边是答案; 如果没有`indegree=2`的点, 说明存在本题中的环路

```CPP
class Solution {
private:
    // dead nodes不影响, 所以可以初始化大一点
    vector<int> father;
    vector<int> sizeList;
public:
    void init(int n){
        father.resize(n+1);
        sizeList.resize(n+1);
        for(int i=1; i<=n; i++){
            father[i] = i;
            sizeList[i] = 1;
        }
    }
    int find(int u){
        return (u==father[u]) ? u : find(father[u]);
    }
    void union_2(int u,int v){
        int pu = find(u);
        int pv = find(v);
        if(pu==pv)
            return ;
        father[pu] = pv;
        sizeList[pv] += sizeList[pu];
    }
    bool inSame(int u, int v){
        return find(u) == find(v);
    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        init(1001);
        for(vector<int> edge: edges){
            int u = edge[0];
            int v = edge[1];
            if(inSame(u, v)==true){
                return edge;
            }
            union_2(u, v);
        }
        return {};
    }
};
```

[LC2316. 统计无向图中无法互相到达点对数](/workspace/2316.%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.cpp)

> 题目描述: https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
> 
> [双周赛](/record/June-Biweek-2.md)第二题, 这题并查集会超时
> 
> TODO: 分析一下为什么并查集超时