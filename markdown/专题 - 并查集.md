#### 并查集 
> 每个集合用一个"树"来表示, 用树根(`father[x]==x`)来唯一标识一棵树
> 
> 关键词: `集合`, `连通块`

##### 1. 实现
> 实现`init`, `union_2`, `find`, `inSame`方法
> 
> - `init()`: `father[i]`设为`i`本身, 每个集合的`size=1`
> - `find(U)`: 递归或者迭代实现, 一直追溯father, 直到`x==father[x]`到达最高祖先
> - `union_2(U, V)`: 将U's最高祖先的`find(u)`设为V's最高祖先, 将`sizeList[V's最高祖先]+=sizeList[U's最高祖先]`
> - `inSame(U,V)`: 追溯各自的最高祖先, 如果相同则U和V处于同一个集合中

##### 2. 并查集的路径压缩
> 在`find(u)`过程中(或者叫结束后), 直接将路径上所有的`father[u]`都指向集合根节点
> 
> 优化效果的来源: **降低树的高度**, 缩短`find(u)`深度

##### 3. 维护额外信息
> `sizeList[N]`: 记录**连通块**中点的个数
> 
> ⚠️注意: `union(u,v)`中, 只有当`fu!=fv`时才更新`sizeList[newRoot]`的值

```CPP
class UnionFindSet {
private:
    vector<int> father;
    vector<int> sizeList;   // 只有作为集合根结点的元素才会被采用
public:
    void init_ufs(int n){
        father.resize(n);
        sizeList.resize(n);
        for(int i=0; i<n; i++){
            father[i] = i;
            sizeList[i] = 1;
        }
    }
    // 递归找根节点
    int find(int u){
        return (u==father[u]) ? u : find(father[u]);
    }
    // 迭代找根节点
    int find2(int u){
        while(father[u]!=u){
            u = father[u];
        }
        return u;
    }
    void union_2(int u, int v){
        int pu = find(u);
        int pv = find(v);
        if(pu==pv)
            return ;
        sizeList[pv] += sizeList[pu];
        father[pu] = pv;
    }
    bool inSame(int u, int v){
        return find(u)==find(v);
    }
};
```

##### [LC684. 冗余连接](/workspace/684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.cpp)
> 题目描述: https://leetcode.cn/problems/redundant-connection/
> 
>从前向后遍历每一条边, 边的两个节点如果最高祖先节点不同(不在同一个集合), 就加入集合
>
> 如果当前边的两个节点最高祖先节点相同(已经出现在同一个集合), 就说明这条边是多余的

> [LC685. 冗余连接Ⅱ](/workspace/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-ii.cpp)是这道题的有向图版本
> 
> 题目描述: https://leetcode.cn/problems/redundant-connection-ii/
> 
> 先检查`indegree=2`的点, 必然有一条边是答案; 如果没有`indegree=2`的点, 说明存在本题中的环路

```CPP
class Solution {
private:
    // dead nodes不影响, 所以可以初始化大一点
    vector<int> father;
    vector<int> sizeList;
public:
    void init(int n){
        father.resize(n+1);
        sizeList.resize(n+1);
        for(int i=1; i<=n; i++){
            father[i] = i;
            sizeList[i] = 1;
        }
    }
    int find(int u){
        return (u==father[u]) ? u : find(father[u]);
    }
    void union_2(int u,int v){
        int pu = find(u);
        int pv = find(v);
        if(pu==pv)
            return ;
        father[pu] = pv;
        sizeList[pv] += sizeList[pu];
    }
    bool inSame(int u, int v){
        return find(u) == find(v);
    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        init(1001);
        for(vector<int> edge: edges){
            int u = edge[0];
            int v = edge[1];
            if(inSame(u, v)==true){
                return edge;
            }
            union_2(u, v);
        }
        return {};
    }
};
```

##### [LC990. 等式方程的可满足性](/workspace/990.%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7.cpp)

> 题目描述: https://leetcode.cn/problems/satisfiability-of-equality-equations/
> 
> 一眼就看出来了呢..先用"=="构建并查集, 再用"!="检查, 如果处于同一个`set`则矛盾
>
> 必须先检查"==", 构建集合, 然后再检查"!="

```CPP
// 省略并查集的定义和基本操作
bool equationsPossible(vector<string>& equations) {
    init_ufs(26);
    // 先检查等式, 构建集合
    for(string eq: equations){
        if(eq[1] == '='){
            union_2(eq[0]-'a', eq[3]-'a');
        }
    }
    // 再检查不等式
    for(string eq: equations){
        if(eq[1] == '!'){
            if(inSame(eq[0]-'a', eq[3]-'a'))
                return false;
        }
    }
    return true;
}
```

##### [LC2316. 统计无向图中无法互相到达点对数](/workspace/2316.%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.cpp)

> 题目描述: https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
> [双周赛](/record/June-Biweek-2.md)第二题, 这题并查集会超时
> 
> Q: 为什么并查集超时?
> 
> ![LC2316](/appendix/LC2316.png)
> 
> 感觉是因为`n`和`edges`数量级很大, 导致频繁`find(U)`开销太高了吧

```CPP
// 省略并查集的定义和基本操作
long long countPairs(int n, vector<vector<int>>& edges) {
    father.resize(n);
    sizeList.resize(n);
    for(int i=0; i<n; i++){
        father[i] = i;
        sizeList[i] = 1;
    }
    for(vector<int> edge: edges){
        union_2(edge[0], edge[1]);
    }
    long long ans = 0;
    // 每一个点对应的点对数目 = 除了它所在集合的所有点数目
    for(int i=0; i<n; i++){
        ans += (n-sizeList[find(i)]);     // sizeList[find(i)]: i所在集合大小
    }
    return ans/2;
}
```


##### [Acwing240. 食物链](https://www.acwing.com/problem/content/242/)
> 同类不一定在同一层, 而是**同类所在层数之差 mod 3 == 0**
> 
> ![食物链](/appendix/acwing-并查集-食物链.png)
