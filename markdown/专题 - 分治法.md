##### 分治法

> 其实说这些题是考察递归也没啥问题...
> 
> 对于**分治问题**, 首先要确定`divide`的标志以及`最小子问题`
> 
> 然后设计循环之类的递归路线完成子问题, 合并最终解


###### [LC241. 为运算表达式设计优先级]()

> divide的条件应该是遇到任意一个标点符号
> 
> 分治的终点 or 最小子问题是只剩数字
> 
> 分治时只需要分别递归左、右两个expression即可

```CPP
// 分治法
// 分治的条件应该是符号, 对于任意符号都可以分成左、右两个子问题
vector<int> diffWaysToCompute(string expression) {
    vector<int> ans;
    for(int i=0; i<expression.size(); i++){
        char cur = expression[i];
        if(cur == '+' || cur == '-' || cur == '*'){
            string left = expression.substr(0, i);
            string right = expression.substr(i+1, expression.size()-i);
            vector<int> leftResult = diffWaysToCompute(left);
            vector<int> rightResult = diffWaysToCompute(right);
            for(int i=0; i<leftResult.size(); i++){
                for(int j=0; j<rightResult.size(); j++){
                    int l = leftResult[i];
                    int r = rightResult[i];
                    if(cur=='+'){
                        ans.push_back(l + r);
                    }
                    if(cur=='-'){
                        ans.push_back(l - r);
                    }
                    if(cur=='*'){
                        ans.push_back(l * r);
                    }
                }
            }
        }
    }
    // 分治的最小问题: 数字
    // 没有出现标点才会使 ans 为空, 说明是数字
    if(ans.size()==0){
        return stoi(expression);
    }
    return ans;
}
```

https://leetcode.cn/problems/different-ways-to-add-parentheses/


###### [LC95. 不同的二叉搜索树Ⅱ]()

> 分治(递归)的终点是`NULL`
>
> 分界条件: `1~n`每个值都可以作为用于分界的根节点

```CPP
vector<TreeNode*> generate(int start, int end){
    vector<TreeNode*> ans;
    // 分治(递归)终点
    // 如果是叶子节点, 则rightTrees和leftTrees可能为空, 导致不能收录degree=1的节点
    if(start>end){
        return {NULL};
    }
    for(int i=start; i<=end; i++){
        vector<TreeNode*> leftTrees = generate(start, i-1);
        vector<TreeNode*> rightTrees = generate(i+1, end);
        for(TreeNode* l : leftTrees){
            for(TreeNode* r: rightTrees){
                TreeNode* root = new TreeNode(i);
                root->left = l;
                root->right = r;
                ans.push_back(root);
            }
        }
    }
    return ans;
}
vector<TreeNode*> generateTrees(int n) {
    return generate(1, n);
}
```

https://leetcode.cn/problems/unique-binary-search-trees-ii