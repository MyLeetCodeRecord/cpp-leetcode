#### 滑动窗口
> 双指针的关键: **单调性**(while条件从满足到不满足要求 / 从不满足到满足要求)
> 
> 简单模板直接套用就可以了, 收缩直到满足`sum`, `cnt`等条件
> 
> 复杂条件可能需要借助`map`等进行匹配或者统计, 这类计数问题(`不重复`,`不超过k次`)可以尝试先收缩左边界, 直至可以加入right的顺序
> 
> 固定尺寸问题要注意识别, 用`if`收缩左边界即可

|简单模板(变长窗口)|固定尺寸|复杂条件|
|  :-:  |  :-:  |  :-:  |
|[LC209. 长度最小的子数组](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)|[LC643. 子数组最大平均数Ⅰ](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%E2%85%B0)|[LC3. 无重复的最长字符串](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc3-%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)|
|[LC1004. 最大连续1的个数III](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%B2)|[LC1052. 爱生气的书店老板](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF)|[LC1695. 删除子数组的最大得分](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc1695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86)|
|[LC1208. 尽可能使字符串相等](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89)|[LC2470. 长度为K子数组中的最大和](/record/2022/Nov-Weekly-1.md)|[LC76. 最小覆盖子串](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)|
|[LC2311. 小于等于K的最长二进制子序列](/workspace/2311.%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E5%BA%8F%E5%88%97.cpp)|   |[LC438. 找到字符串中所有字母异位词](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D)|
|[LC713. 乘积小于K的子数组](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)|   |[LC567. 字符串的排列](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97)|
|   |   |[LC904. 水果成篮](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)|
|   |   |[AcWing799. 最长连续不重复子序列](/acwing/Section%201/6_%E5%8F%8C%E6%8C%87%E9%92%88_%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97.cpp)|


###### 模板
> 右边界无脑++, 根据条件收缩左边界

```CPP
初始化窗口window

while 右边界 < 合法条件{
    # 右边界扩张
    window右边界+1
    更新状态信息
    # 左边界收缩
    while left < right and 符合收缩条件 {
        window左边界+1
        更新状态信息
    }
}
```


###### [LC3. 无重复的最长字符串](/workspace/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.cpp)

> 题目: https://leetcode.cn/problems/longest-substring-without-repeating-characters/
> 
> 借助`map`记录字符出现次数, `while`条件为`mp[s[right]]>1`

```CPP
int lengthOfLongestSubstring(string s) {
    unordered_map<int, int> mp;
    int ans = 0;    // 注意s长度可能为0
    for(int l=0, r=0; r<s.size(); r++){
        mp[s[r]]++;
        while(mp[s[r]] > 1){
            mp[s[l++]]--;
        }
        ans = max(ans, r-l+1);
    }
    return ans;
}
```


###### [LC1695. 删除子数组的最大得分](/workspace/1695.%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.cpp)

> [问题描述](https://leetcode.cn/problems/maximum-erasure-value/): 正整数数组`nums`, 求累加和最大的无重复元素的连续子数组, 返回其累加和的值
> 
> 和[LC3. 无重复的最长字符串](/workspace/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.cpp)差不多, 用`map`, `set`都可以...

```CPP
int maximumUniqueSubarray(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> mp;
    int sum = 0;
    int left = 0;
    int right = 0;
    while(right < nums.size()){
        while(left<right && mp.find(nums[right])!=mp.end() && mp[nums[right]] != 0){
            sum -= nums[left];
            mp[nums[left++]]--;
        }
        mp[nums[right]]++;
        sum += nums[right++];
        ans = max(ans, sum);
    }
    return ans;
}
```


###### [LC76. 最小覆盖子串](/workspace/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.cpp)

> [问题描述](https://leetcode.cn/problems/minimum-window-substring/): 返回`s`中涵盖`t`所有字符的最小子串, 不存在则返回空字符串
>
> 正确做法: 动态比较窗口内子串是否符合条件 ✅
> 
> 维护窗口时使用一个变量cnt记录已经满足条件的mp_t中的key, 作为子串包含t的判断条件
> 
> 不好但是能过的做法: 每个窗口位置比较两个`map` ❌
> 
> ![LC76](/appendix/LC76.png)

```CPP
string minWindow(string s, string t) {
    unordered_map<char, int> mp_t;  // 静态
    unordered_map<char, int> mp_s;  // 动态维护
    for(char ch: t)
        mp_t[ch]++;
    bool exist = false;
    string ans = s;
    int cnt = 0;
    int left = 0;
    for(int right=0; right<s.size(); right++){
        mp_s[s[right]]++;
        if(mp_t.find(s[right])!=mp_t.end() && mp_s[s[right]] == mp_t[s[right]])
            cnt++;
        // left收缩的条件: 1. 其它字符  2. 个数超额的字符
        // 这里必须判断left范围, e.g. s="a" t="b"
        while(left<s.size() && mp_t.find(s[left])==mp_t.end() || mp_s[s[left]] > mp_t[s[left]]){
            mp_s[s[left++]]--;
        }
        if(cnt == mp_t.size()){
            exist = true;
            if(right-left+1 <= ans.size()){
                ans = s.substr(left, right-left+1);
            }
        }
    }
    return exist ? ans : "";
}
```


###### [LC209. 长度最小的子数组](/workspace/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp)

> 题目: https://leetcode.cn/problems/minimum-size-subarray-sum/
>
> 问题描述: 含有n个**正整数**的数组`nums`和一个正整数`target`, 返回满足其和`sum≥ target`的长度最小的连续子数组长度
> 
> Q: 为什么可以用`滑动窗口`?
>
> A: 滑动窗口求连续区间和, 并**不需要有序**, 而是依赖于「**所有元素均为正数**」的性质, 然后变成滑窗模板题

```CPP
int minSubArrayLen(int target, vector<int>& nums) {
    int ans = INT_MAX;
    int left = 0;
    int right = 0;
    int sum = 0;
    while(right < nums.size()){
        // 扩大右边界
        sum += nums[right++];
        // 收缩左边界
        while(left<right && sum >= target){   // 满足target后还要保证子数组尽可能短
            sum -= nums[left++];
            ans = min(ans, right-left+1);
        }
    }
    return (ans==INT_MAX) ? 0 : ans;
}
```


###### [LC713. 乘积小于K的子数组](/workspace/713.%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp)

> 题目: https://leetcode.cn/problems/subarray-product-less-than-k/
> 
> 与[LC209. 长度最小的子数组](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)差不多, 只不过答案在`while`外面求得

```CPP
// 子数组是连续的, 并且每个值为正数, 因此还是可以用滑动窗口
int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    long long product = 1;
    int l = 0, r = 0;
    int cnt = 0;
    while(r < nums.size()){
        product *= nums[r++];
        while(l<r && product>=k){
            product /= nums[l++];
        }
        cnt += r-l;     // 固定right, 枚举left
    }
    return cnt;
}
```


###### [LC643. 子数组最大平均数Ⅰ](/workspace/643.%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-i.cpp)

> 题目: https://leetcode.cn/problems/maximum-average-subarray-i/
> 
> `固定窗口大小`的滑动窗口问题
> 
> 要注意更新ans的位置(比如窗口内必须刚好包含 k 个元素)
> 
> 并且收缩左边界的`while`可以用`if`替代 (只会从`k+1`收缩一步到`k`)
> 
> 注意任意子数组都为负数的情况, ans不要初始化为0

```CPP
// 滑动窗口 - 窗口大小固定
double findMaxAverage(vector<int>& nums, int k) {
    int ans = INT_MIN;      // 要考虑ans是负数
    int sum = 0;
    int left = 0;
    int right = 0;
    while(right<nums.size()){
        sum += nums[right++];
        if(right-left == k){
            ans = max(ans, sum);
            sum -= nums[left++];
        }
    }
    return (double)ans / k;
}
```


###### [LC438. 找到字符串中所有字母异位词](/markdown/LC438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md)
> `固定尺寸滑动窗口` ✅
> 
> `可变窗口+跳过无效字符` ❌

```CPP
bool checkInclusion(string s1, string s2){
    int k = s1.size();
    int n = s2.size();
    // 用vector代替map, 方便直接比较
    vector<int> mp1;
    vector<int> mp2;
    for(int i=0; i<k; i++){
        mp1[s1[i] - 'a']++;
        mp2[s2[i]-'a']++;
    }
    // 检查s2窗口是否和s1是异位词
    if(mp1 == mp2)
        return true;
    for(int i=k; i<n; i++){
        mp2[s1[i-k]-'a']--;
        mp2[s2[i]-'a']++;
        if(mp1 == mp2)
            return true;
    }
    return false;
}
```


###### [LC567. 字符串的排列](/workspace/567.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.cpp)
> [这道题](https://leetcode.cn/problems/permutation-in-string/)与[LC438. 找到字符串中所有字母异位词](/markdown/%E4%B8%93%E9%A2%98%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md#lc438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D)是同一个


###### [LC1004. 最大连续1的个数III](/workspace/1004.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0-iii.cpp)

> 题目: https://leetcode.cn/problems/max-consecutive-ones-iii/
> 
> 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数
> 
> 要求窗口内有最多 k 个 0, 需要一个`zeroCnt`或者`直接使用k`来记录
> 
> 扩大右窗口时, 如果`nums[right]==0`就用掉一个额度
> 
> `while`收缩左窗口时, 如果`nums[left]==0`就释放一个额度
> 
> 为啥有操作系统调度的感觉了...
> 
> 收缩左窗口结束后, `zeroCnt==k` or `k==0`时更新`ans`

```CPP
// 滑动窗口
int longestOnes(vector<int>& nums, int k) {
    int left = 0;
    int right = 0;
    int ans = k;
    while(right < nums.size()){
        // 扩大右边界, right位置为0时k--
        k -= (nums[right++]==0);
        // 收缩左边界, 直到k非负
        while(k < 0){
            if(nums[left]==0)
                k++;
            left++;
        }
        // 此时k=0
        ans = max(ans, right-left);
    }
    return ans;
}
```


###### [LC1208. 尽可能使字符串相等](/workspace/1208.%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89.cpp)

> 题目: https://leetcode.cn/problems/get-equal-substrings-within-budget/
> 
> 与[LC1004. 最大连续1的个数III](/workspace/1004.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0-iii.cpp)类似, 不是计数, 而是计算ascii码差值

```CPP
// s和t是对齐的两个字符串, 所以一个滑动窗口, 控制窗口内不同的字符差值不超过maxCost即可
int equalSubstring(string s, string t, int maxCost) {
    int left = 0;
    int right = 0;
    int ans = 0;
    while(right<s.size()){
        // 扩大右窗口
        maxCost -= abs(s[right] - t[right]);   // 如果不同, 花费一个cost
        right++;
        // 收缩左窗口
        while(maxCost < 0){
            maxCost += abs(s[left] - t[left]); // 释放一个cost
            left++;
        }
        ans = max(ans, right-left);
    }
    return ans;
}
```


###### [LC2311. 小于等于K的最长二进制子序列](/workspace/2311.%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E5%BA%8F%E5%88%97.cpp)

> 注意这道题是`子序列`, 不要求连续, 而且最好用`贪心`做...
> 
> 因为`滑动窗口`解法中, `left`与`num`的区间不是对齐的, 而是包含了前导零...有点不好理解

```CPP
int trans(int n){
    int tmp = n;
    int k = 0;
    while(n / 2 != 0){
        n /= 2;
        k++;
    }
    int highest = 1;
    while(k!=0){
        highest *= 2;
        k--;
    }
    return tmp-highest;
}
int longestSubsequence(string s, int k) {
    int ans = 1;
    int left = 0;
    int right = 0;
    int sum = 0;
    while(right < s.size()){
        sum = sum * 2 + (s[right++]-'0');
        while(sum > k && left<right){
            left++;
            sum = trans(sum);
        }
        ans = max(ans, right-left);
    }
    return ans;
}
```


###### [LC1052. 爱生气的书店老板](/workspace/1052.%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF.cpp)
> 题目: https://leetcode.cn/problems/grumpy-bookstore-owner/
> 
> 想复杂了xd, 这是个固定窗口的问题, ans是原始的sum+因为buff窗口而新增的顾客的最大值
> 
> 固定窗口用`if`收缩左边界即可
> 
> 如果不分解问题, 不固定窗口大小, 难度就来到 “维护最左和最右1” 这边
> 
> Q: left能不能直接"跳到"下个 1 的位置
> 
> A: left跳出收缩左边界的`if`语句后已经在1位置了, 不用跳了...

```CPP
// 固定尺寸的滑动窗口
// ans是 "原始的sum + 因为buff窗口而新增的顾客"的最大值
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {
    int ans = 0;
    int sum = 0;
    int left = 0;
    int right = 0;
    for(int i=0; i<customers.size(); i++){
        sum += (grumpy[i]==0) ? customers[i] : 0;
    }
    while(right < customers.size()){
        // 扩大右窗口
        sum += ((grumpy[right]==1) ? customers[right] : 0);
        right++;
        // 收缩左窗口
        if(right-left == k){
            ans = max(ans, sum);
            sum -= ((grumpy[left]==1) ? customers[left] : 0);
            left++;
        }
    }
    return ans;
}
```

###### [LC904. 水果成篮](/workspace/904.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE.cpp)

> 题目: https://leetcode.cn/problems/fruit-into-baskets/
> 
> 用`map`来维护两个篮子

```CPP
int totalFruit(vector<int>& fruits) {
    unordered_map<int, int> mp;
    int ans = 0;
    int left = 0;
    int right = 0;
    while(right < fruits.size()){
        if(mp.size() < 2 || mp.find(fruits[right])!=mp.end()){
            ans = max(ans, right-left+1);
            mp[fruits[right++]]++;
        }
        else if(left<right && mp.find(fruits[left])!=mp.end() ){
            if(mp[fruits[left]]==1){
                mp.erase(fruits[left++]);
            }
            else{
                mp[fruits[left++]]--;
            }
        }
    }
    return maxLen;
}
```