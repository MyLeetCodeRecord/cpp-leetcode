##### 区间问题

###### [LC435. 无重叠区间]()

> 在每次选择中，选择的区间结束越早，留给后面的区间的空间越大
> 
> 因此按结束时间排序, 如果当前区间`start` >= 上一个采用区间的`end`, 则可以保留, 并更新`end`

```CPP
// 按结束时间排序 (说了八百回, 不加引用超时
bool static cmp(vector<int>& l, vector<int>& r){
    return l[1]<r[1];
}
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    int end = INT_MIN;
    int cnt = 0;
    for(int i=0; i<intervals.size(); i++){
        if(intervals[i][0] >= end){
            cnt++;
            end = intervals[i][1];
        }
    }
    return intervals.size() - cnt;
}
```

https://leetcode.cn/problems/non-overlapping-intervals/



###### [452. 用最少数量的箭引爆气球]()
> 与[LC435. 无重叠区间]()类似, 都是**按右端点排序**
> 
> 尽量都用points[0][1]来初始化, 而不是`INT_MIN`, 而不是0
> 
> 比如本题的测试用例`[[-2147483648,2147483647]]`, `points[0][0]==INT_MIN`
```CPP
// 按右边界排序
bool static cmp(vector<int> &l, vector<int> &r){
    return l[1] < r[1];
}
int findMinArrowShots(vector<vector<int>>& points) {
    sort(points.begin(), points.end(), cmp);
    int end = points[0][1];
    int cnt = 1;
    for(int i=0; i<points.size(); i++){
        if(points[i][0] > end){
            end = points[i][1];
            cnt++;
        }
    }
    return cnt;
}
```

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/