#### 差分

> 问题: m个操作, 每个操作对`nums[l,r]`每个位置加一个相同的数a
> 
> 转化为差分问题 => `diff[l] += a` & `diff[r+1] -= a`(如果r+1不越界)
> 
> 最后再对`diff数组`求`前缀和`恢复到原始数组


##### [LC1109. 航班预定统计](/workspace/1109.%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1.cpp)

> 直观的差分问题, 注意下标从 1 开始

```CPP
vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
    // 计算差分
    vector<int> diff(n, 0);
    for(vector<int> book: bookings){
        diff[book[0]-1] += book[2];
        if(book[1] < n)
            diff[(book[1]-1)+1] -= book[2];
    }
    // 如果不创建额外空间prefixSum可以直接覆盖在diff上
    vector<int> prefixSum(n, 0);
    prefixSum[0] = diff[0];
    for(int i=1; i<n; i++){
        prefixSum[i] = prefixSum[i-1]+diff[i];
    }
    return prefixSum;
}
```
https://leetcode.cn/problems/corporate-flight-bookings


##### [LC1094. 拼车](/workspace/1094.%E6%8B%BC%E8%BD%A6.cpp)

> 注意index开始位置为 0, 与[LC1109. 航班预定统计](https://leetcode.cn/problems/corporate-flight-bookings)不同
> 
> 对于`prefixSum[0]`也要判断`capacity`

```CPP
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        // 计算差分(Index 从 0 开始)
        int maxLen = 0;
        vector<int> diff(1001, 0);
        for(vector<int> t: trips){
            diff[t[1]] += t[0];
            diff[t[2]] -= t[0];
            maxLen = max(maxLen, max(t[1], t[2]));
        }
        // 这里的前缀和省略为两个cumSum即可
        // int cumSum = diff[0];
        vector<int> prefixSum(maxLen+1, 0);
        prefixSum[0] = diff[0];
        if(prefixSum[0] > capacity)
            return false;
        for(int i=1; i<=maxLen; i++){
            prefixSum[i] = prefixSum[i-1]+diff[i];
            if(prefixSum[i] > capacity)
                return false;
        }
        return true;
    }
};
```
https://leetcode.cn/problems/car-pooling/