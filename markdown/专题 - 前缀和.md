#### å‰ç¼€å’Œ

> ç›®çš„: å¿«é€Ÿæ±‚å‡ºæ•°ç»„ä¸­ã€Œè¿ç»­ã€ä¸€æ®µçš„å’Œ
> 
> æ³¨æ„`prefixSum`çš„ä¸‹æ ‡é”™å¼€ä¸€ä½, ä»1å¼€å§‹

##### [LC724. å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡](/workspace/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.cpp)

> ä¸€ç»´å‰ç¼€å’Œ(é”™å¼€ä¸€ä½), ç„¶åæ‰¾æ»¡è¶³`prefixSum[i]*2 == allSum - nums[i]`çš„ä½ç½®`i`
> 
> p.s. è¿™é¢˜çš„å‰ç¼€å’Œä¸é”™ä½æ›´å¥½å†™ä¸€äº›
> 
> æœç´¢æƒ³åˆ°`äºŒåˆ†æŸ¥æ‰¾`æ˜¯å¥½äº‹...ä½†è¿™é¢˜ä¹Ÿä¸æ˜¯æœ‰åºå‘€...

```CPP
int pivotIndex(vector<int>& nums) {
    // å‰ç¼€å’Œ(é”™å¼€ä¸€ä½)
    vector<int> prefixSum(nums.size()+1, 0);
    for(int i=1; i<=nums.size(); i++){
        prefixSum[i] = nums[i-1] + prefixSum[i-1];
    }
    // æ‰¾æ»¡è¶³æ¡ä»¶çš„ä¸‹æ ‡ i
    for(int i=0; i<nums.size(); i++){
        // ä¹Ÿå¯ä»¥ä¸¤è¾¹éƒ½æŠŠnums[i]åŒ…å«è¿›å»
        if(prefixSum[i]*2 == prefixSum.back()-nums[i])
            return i;
    }
    return -1;
}
```
https://leetcode.cn/problems/find-pivot-index/


##### [LC303. åŒºåŸŸå’Œæ£€ç´¢-æ•°ç»„ä¸å¯å˜](/workspace/303.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.cpp)

> æ ‡å‡†çš„å‰ç¼€å’Œæ¨¡æ¿, æ³¨æ„`prefixSum`ä¸‹æ ‡å’ŒèŒƒå›´ä¸‹æ ‡çš„å¯¹é½

```CPP
vector<int> prefixSum;
NumArray(vector<int>& nums) {
    prefixSum.resize(nums.size()+1);
    fill(prefixSum.begin(), prefixSum.end(), 0);
    for(int i=1; i<=nums.size(); i++){
        prefixSum[i] = prefixSum[i-1]+nums[i-1];
    }
}

int sumRange(int left, int right) {
    return prefixSum[right+1]-prefixSum[left];
}
```
https://leetcode.cn/problems/range-sum-query-immutable/


##### [LC560. å’Œä¸ºKçš„å­æ•°ç»„](/workspace/560.%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp)

> Keyword: `å‰ç¼€å’Œ`  `map`
> 
> `nums[i]`å¯èƒ½å°äº0, å› æ­¤ä¸å¯ä»¥ç”¨`åŒæŒ‡é’ˆ`/`æ»‘åŠ¨çª—å£`
> 
> åˆå§‹æƒ³æ³•: ä½¿ç”¨`å‰ç¼€å’Œ`, æ¥ä¸‹æ¥è®¡ç®—åŒºé—´å’Œ(æšä¸¾<èµ·ç‚¹,ç»ˆç‚¹>) => è¶…æ—¶ ([12/23]ğŸ¤ªè¶…æ—¶æ‰“å¡+1)
> 
> æšä¸¾å·¦ã€å³ä¸¤ä¸ªç«¯ç‚¹è¶…æ—¶ => ä½¿ç”¨`map`è®°å½•å·²ç»å‡ºç°çš„`prefixSum[i]`
>   - å¦‚æœ(å·¦ä¾§)å·²ç»æœ‰å€¼ä¸º`prefixSum[i]-k`çš„å‰ç¼€å’Œ, å¦‚æœæœ‰, ä¸ªæ•°åº”ä¸º`mp[prefixSum[i]-k]`
>   - å¹¶ä¸”å¯¹æ¯ä¸ª`prefixSum[i]`è®¡æ¬¡, å³`mp[prefixSum[i]]++`
>   - ä¸ä¼šé‡å¤è®¡æ•°, å› ä¸ºæ¯æ¬¡ä¸º`prefixSum[i]`æ‰¾å€¼ä¸º`prefixSum[i]-k`çš„å‰ç¼€å’Œä¸ªæ•°æ—¶, éƒ½ä¿æŒ`i`ä¸ºå³è¾¹ç•Œ
> 
> ç›¸ä¼¼é¢˜ç›®: [å‰‘æŒ‡offer50. å‘ä¸‹çš„è·¯å¾„èŠ‚ç‚¹ä¹‹å’Œ](/%E5%89%91%E6%8C%87offer/50.%20%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C.md)

```CPP
int subarraySum(vector<int>& nums, int k) {
    int n = nums.size();
    // 1. æ±‚å‰ç¼€å’Œ(é”™å¼€ä¸€ä½ä¹Ÿæ–¹ä¾¿åé¢è®¡ç®—åŒºé—´å’Œ)
    vector<int> prefixSum(n+1, 0);
    for(int i=1; i<=n; i++){
        prefixSum[i] = prefixSum[i-1] + nums[i-1];
    }
    // 2. ä»å·¦åˆ°å³æ‰©å»ºmapè®°å½•å·¦è¾¹å‰ç¼€å’Œå€¼çš„å‡ºç°æ¬¡æ•°
    unordered_map<int, int> mp;
    mp[0] = 1;
    int ans = 0;
    for(int i=1; i<=n; i++){
        ans += mp[prefixSum[i]-k];
        mp[prefixSum[i]]++;
    }
    return ans;
}
```
https://leetcode.cn/problems/subarray-sum-equals-k



#### äºŒç»´å‰ç¼€å’Œ

> `sum[x1:x2][y1:y2] = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]`
> 
> åˆå§‹åŒ–
>   - Row 0 & Col 0: ä¸€ç»´å‰ç¼€å’Œ
>   - `sum[i][j] = nums[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]`


##### [304. äºŒç»´åŒºåŸŸå’Œæ£€ç´¢-çŸ©é˜µä¸å¯å˜](/workspace/304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98.cpp)

> æ ‡å‡†çš„äºŒç»´å‰ç¼€å’Œæ¨¡æ¿, æ³¨æ„å°†å‰ç¼€å’Œæ•°ç»„ä¸‹æ ‡ä¸èŒƒå›´ä¸‹æ ‡å¯¹é½

```CPP
class NumMatrix {
public:
    vector<vector<int>> preSum;
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> prefixSum(m+1, vector(n+1, 0));
        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                prefixSum[i][j] = prefixSum[i-1][j]+prefixSum[i][j-1]-prefixSum[i-1][j-1] + matrix[i-1][j-1];
            }
        }
        preSum = prefixSum;
    }
    int sumRegion(int x1, int y1, int x2, int y2) {
        x1++;   y1++;   x2++;   y2++;
        return preSum[x2][y2]-preSum[x1-1][y2]-preSum[x2][y1-1]+preSum[x1-1][y1-1];
    }
};
```
https://leetcode.cn/problems/range-sum-query-2d-immutable/


##### [LC1314. çŸ©é˜µåŒºåŸŸå’Œ](/workspace/1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C.cpp)

> å¯¹äºæ¯ä¸€ä¸ª`(i, j)`æ±‚`prefixSum[i-k:i+k][j-k:j+k]`, æ³¨æ„åˆ¤æ–­ä¸‹æ ‡è¶Šç•Œ

```CPP
vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    int m = mat.size();
    int n = mat[0].size();
    // æ„é€ å‰ç¼€å’Œ
    vector<vector<int>> prefixSum(m+1, vector<int>(n+1, 0));
    for(int i=1; i<=m; i++){
        for(int j=1; j<=n; j++){
            prefixSum[i][j] = prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1] + mat[i-1][j-1];
        }
    }
    // æšä¸¾ä¸­å¿ƒä½ç½®
    for(int i=1; i<=m; i++){
        for(int j=1; j<=n; j++){
            int x1 = (i-k<1) ? 1 : i-k;
            int y1 = (j-k<1) ? 1 : j-k;
            int x2 = (i+k>m) ? m : i+k;
            int y2 = (j+k>n) ? n : j+k;
            mat[i-1][j-1] = prefixSum[x2][y2] - prefixSum[x1-1][y2] - prefixSum[x2][y1-1] + prefixSum[x1-1][y1-1];
        }
    }
    return mat;
}
```
https://leetcode.cn/problems/matrix-block-sum/


#### è®¡æ•°å‰ç¼€å’Œ
##### [LC2483. å•†åº—çš„æœ€å°‘ä»£ä»·](/workspace/2483.%20%E5%95%86%E5%BA%97%E7%9A%84%E6%9C%80%E5%B0%91%E4%BB%A3%E4%BB%B7.cpp): 1ï¸âƒ£â•1ï¸âƒ£åŒå‘¨èµ›ç¬¬ä¸‰é¢˜
> - è®¡æ•°å‰ç¼€å’Œ: å¯¹å·¦è¾¹å‡ºç°è¿‡çš„æ‰€æœ‰`N`(æˆ–è€…`Y`)è®¡æ•°
> 
> - æšä¸¾åˆ†ç•Œç‚¹, æ±‚å·¦ä¾§`N`çš„ä¸ªæ•° + å³ä¾§`Y`çš„ä¸ªæ•°ä½œä¸º`cost`

```CPP
int bestClosingTime(string customers) {
    // nCnt[i]: ç»Ÿè®¡ 0~i ä¸­'N'çš„ä¸ªæ•°
    int n = customers.size();
    vector<int> nCnt(n+1);  // å‰ç¼€å’Œæ•°ç»„
    nCnt[0] = 0;
    for(int i=1; i<=n; i++){
        nCnt[i] = nCnt[i-1] + (customers[i-1]=='N');
    }
    int ans = 0;
    int minCost = n;
    for(int i=0; i<=n; i++){
        // cost: ä» i ä½ç½®æˆªæ–­(æ³¨æ„nCnt[]æ˜¯ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨çš„)
        //   - å‰é¢'N'çš„ä¸ªæ•° => nCnt[N]
        //   - åé¢'Y'çš„ä¸ªæ•° => n-i-(nCnt[n]-nCnt[i])   // æ‹¬å·é‡Œçš„éƒ¨åˆ†(nCnt[n]-nCnt[i]), å‰ç¼€å’Œçš„æ€æƒ³
        int cost = nCnt[i] + (n - i - nCnt[n] +nCnt[i]);
        if(cost < minCost){
            minCost = cost;
            ans = i;
        }
    }
    return ans;
}
```
https://leetcode.cn/problems/minimum-penalty-for-a-shop/


##### [å‰‘æŒ‡offer50. å‘ä¸‹çš„è·¯å¾„èŠ‚ç‚¹ä¹‹å’Œ](/%E5%89%91%E6%8C%87offer/50.%20%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C.md)

> æ±‚ä¸€æ®µè·¯å¾„çš„æ€»å’Œ, å¾ˆåƒ`å‰ç¼€å’Œ`, ä¸è¿‡æœ¬é¢˜æ›´åœ¨æ„å½“å‰è·¯å¾„ä¸Š**å·²ç»å­˜åœ¨å‡ ä¸ª**`x-target`, è€Œä¸æ³¨é‡åœ¨è·¯å¾„ä¸Šçš„å…·ä½“ä½ç½®
> 
> äºæ˜¯å°±å˜æˆäº†ã€Œæ ‘çŠ¶ã€çš„[LC560. å’Œä¸ºKçš„å­æ•°ç»„](/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%89%8D%E7%BC%80%E5%92%8C.md#lc560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)
>
> åˆå§‹åŒ–ä¸€ä¸ª`mp[0]=1`, è¡¨ç¤ºç©ºæ ‘
> 
> `backtrack(root, sum, target)`:
> - å°†`root->val`åŠ å…¥`sum`
> - å¦‚æœå½“å‰DFSè·¯å¾„ä¸Šå·²ç»å­˜åœ¨`x-target`, `ans += mp[sum-target]`
> - è®°å½•å½“å‰è·¯å¾„ä¸Šçš„å‰ç¼€å’Œ, `mp[sum]++`
> - é€’å½’å·¦å³å­æ ‘
> - é€’å½’å·¦å³å­æ ‘åè¦å–æ¶ˆå¯¹`sum`çš„è®¡æ•°, `mp[sum]--`
> 
> âš ï¸æ³¨æ„è·¯å¾„å’Œå¯èƒ½å‘ç”Ÿ`int`æº¢å‡º

```CPP
unordered_map<long long, int> mp;   // åœ¨å½“å‰è·¯å¾„ä¸Š, è®°å½•ä»rootåˆ°curä¸Šçš„pathSumå‡ºç°çš„æ¬¡æ•°
int ans = 0;
void backtrack(TreeNode* root, long long pathSum, int targetSum){
    if(root==NULL)
        return ;
    pathSum += root->val;
    // å‰ç¼€å’Œ, åº”è¯¥æ˜¯pathSum - x = targetSum
    ans += mp[pathSum-targetSum];
    mp[pathSum]++;
    backtrack(root->left, pathSum, targetSum);
    backtrack(root->right, pathSum, targetSum);
    mp[pathSum]--;
}
int pathSum(TreeNode* root, int targetSum) {
    // ! å’ŒLC560ä¸€æ ·ï¼Œ åˆ«å¿˜äº†mp[0]=1
    mp[0] = 1;
    backtrack(root, 0, targetSum);
    return ans;
}
```
https://leetcode.cn/problems/6eUYwP/


##### [LC2559. ç»Ÿè®¡èŒƒå›´å†…çš„å…ƒéŸ³å­—ç¬¦ä¸²æ•°](/record/2023/Weekly%20331.md): å‘¨èµ›331ç¬¬äºŒé¢˜

> æ³¨æ„è¯»é¢˜, ä»¥aeiouå¼€å¤´æˆ–ç»“å°¾çš„å•è¯, ä¸æ˜¯åŒ…å«aeiou

```CPP
unordered_set<char> st = {'a','e','i','o','u'};
bool check(string word){
    if(st.find(word[0])==st.end())
        return false;
    if(st.find(word.back())==st.end())
        return false;
    return true;
}
vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {
    int n = words.size();
    vector<int> prefixSum(n+1, 0);
    for(int i=1; i<=n; i++){
        prefixSum[i] = prefixSum[i-1] + (check(words[i-1])==true);
        cout<<prefixSum[i]<<" ";
    }
    int m = queries.size();
    vector<int> ans(m, 0);
    for(int i=0; i<m; i++){
        ans[i] = prefixSum[queries[i][1]+1] - prefixSum[queries[i][0]];
    }
    return ans;
}
```
https://leetcode.cn/problems/count-vowel-strings-in-ranges/