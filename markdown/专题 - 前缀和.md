#### 前缀和

> 目的: 快速求出数组中一段的和
> 
> 注意`prefixSum`的下标错开一位, 从1开始

##### [LC724. 寻找数组的中心下标](/workspace/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.cpp)

> 一维前缀和(错开一位), 然后找满足`prefixSum[i]*2 == allSum - nums[i]`的位置i
> 
> 搜索想到`二分查找`是好事...但这题也不是有序呀...

```CPP
int pivotIndex(vector<int>& nums) {
    // 前缀和(错开一位)
    vector<int> prefixSum(nums.size()+1, 0);
    for(int i=1; i<=nums.size(); i++){
        prefixSum[i] = nums[i-1] + prefixSum[i-1];
    }
    // 找满足条件的下标 i
    for(int i=0; i<nums.size(); i++){
        if(prefixSum[i]*2 == prefixSum.back()-nums[i])
            return i;
    }
    return -1;
}
```


##### [LC303. 区域和检索-数组不可变](/workspace/303.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.cpp)

> 标准的前缀和应用, 注意`prefixSum`要不要错开一位

```CPP
class NumArray {
private:
    vector<int> prefixSum;
public:
    NumArray(vector<int>& nums) {
        prefixSum.resize(nums.size());
        fill(prefixSum.begin(), prefixSum.end(), 0);
        prefixSum[0] = nums[0];
        for(int i=1; i<nums.size(); i++){
            prefixSum[i] = prefixSum[i-1]+nums[i];
        }
    }
    
    int sumRange(int left, int right) {
        if(right>=prefixSum.size())
            return prefixSum.back();
        if(left==0)
            return prefixSum[right];
        else
            return prefixSum[right]-prefixSum[left-1];
    }
};
```
https://leetcode.cn/problems/range-sum-query-immutable/


##### [LC560. 和为K的子数组](/workspace/560.%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp)

> Keyword: `前缀和`  `map/hash`
> 
> `nums[i]`可能小于0, 因此不可以用`双指针`/`滑动窗口`
> 
> 初始想法: 使用`前缀和`, 接下来计算区间和(枚举<起点,终点>) => 超时
> 
> 枚举左、右两个端点超时 => 使用`map`记录已经出现的`prefixSum[i]`
>   - 如果(左侧)已经有值为`prefixSum[i]-k`的前缀和, 如果有, 个数应为`mp[prefixSum[i]-k]`
>   - 并且对每个`prefixSum[i]`计次, 即`mp[prefixSum[i]]++`
>   - 不会重复计数, 因为每次为`prefixSum[i]`找值为`prefixSum[i]-k`的前缀和个数时, 都保持`i`为右边界

```CPP
int subarraySum(vector<int>& nums, int k) {
    // 1. 求前缀和(错开一位也方便后面计算区间和)
    vector<int> prefixSum(nums.size()+1, 0);
    for(int i=1; i<=nums.size(); i++){
        prefixSum[i] = prefixSum[i-1] + nums[i-1];
    }
    // 2. map记录前缀和
    unordered_map<int, int> mp;
    int ans = 0;
    mp[0] = 1;
    for(int i=1; i<=nums.size(); i++){
        if(mp.find(prefixSum[i]-k)!=mp.end())
            ans += mp[prefixSum[i]-k];
        mp[prefixSum[i]]++;
    }
    return ans;
}
```
https://leetcode.cn/problems/subarray-sum-equals-k



#### 二维前缀和

> `sum[x1:x2][y1:y2] = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]`
> 
> 初始化
>   - Row 0 & Col 0: 一维前缀和
>   - `sum[i][j] = nums[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]`


##### [304. 二维区域和检索-矩阵不可变](/workspace/304.%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98.cpp)

> 标准的二维前缀和, 注意`row1`和`col1`为 0 的情况

```CPP
class NumMatrix {
private:
    vector<vector<int> > preSum;
    int m, n;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        vector<vector<int> > prefixSum(m, vector<int>(n, 0));
        prefixSum[0][0] = matrix[0][0];
        for(int i=1; i<m; i++){
            prefixSum[i][0] = matrix[i][0] + prefixSum[i-1][0];
        }
        for(int j=1; j<n; j++){
            prefixSum[0][j] = matrix[0][j] + prefixSum[0][j-1];
        }
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                prefixSum[i][j] = matrix[i][j] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1];
            }
        }
        preSum = prefixSum;
    }
    int sumRegion(int row1, int col1, int row2, int col2) {
        if(row1==0 && col1==0)
            return preSum[row2][col2];
        if(row1==0)
            return preSum[row2][col2] - preSum[row2][col1-1];
        if(col1==0)
            return preSum[row2][col2] - preSum[row1-1][col2];
        return preSum[row2][col2] - preSum[row1-1][col2] - preSum[row2][col1-1] + preSum[row1-1][col1-1];
    }
};
```


##### [LC1314. 矩阵区域和](/workspace/1314.%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C.cpp)

> 对于每一个`(i, j)`求`prefixSum[i-k:i+k][j-k:j+k]`, 注意判断下标越界

```CPP
vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    int m = mat.size();
    int n = mat[0].size();
    vector<vector<int> > preSum = initPrefixSum(mat);
    vector<vector<int> > ans(m, vector<int>(n, 0));
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            // 对下标越界进行处理
            int row1 = (i-k>=0) ? (i-k) : 0;
            int row2 = (i+k<m) ? (i+k) : (m-1);
            int col1 = (j-k>=0) ? (j-k) : 0;
            int col2 = (j+k<n) ? (j+k) : (n-1);
            ans[i][j] = getOneArea(preSum, row1, col1, row2, col2);
        }
    }
    return ans;
}
```


#### 计数前缀和
##### [LC2483. 商店的最少代价](https://leetcode.cn/problems/minimum-penalty-for-a-shop/): 1️⃣➕1️⃣双周赛第三题

```CPP
int bestClosingTime(string customers) {
    // nCnt[i]: 统计 0~i 中'N'的个数
    int n = customers.size();
    vector<int> nCnt(n+1);  // 前缀和数组
    nCnt[0] = 0;
    for(int i=1; i<=n; i++){
        nCnt[i] = nCnt[i-1] + (customers[i-1]=='N');
    }
    int ans = 0;
    int minv = 0x3f3f3f3f;
    for(int i=0; i<=n; i++){
        // cost: 从 i 位置截断(注意nCnt[]是从下标1开始存储的)
        //   - 前面'N'的个数 => nCnt[N]
        //   - 后面'Y'的个数 => n-i-(nCnt[n]-nCnt[i])   // 括号里的部分(nCnt[n]-nCnt[i]), 前缀和的思想
        int cost = nCnt[i] + (n - i - nCnt[n] +nCnt[i]);
        if(cost < minv){
            ans = i;
            minv = cost;
        }
    }
    return ans;
}
```


##### [向下的路径节点之和](/%E5%89%91%E6%8C%87offer/50.%20%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C.md)

> 求一段路径的总和, 很像`前缀和`, 不过本题更在意当前路径上**已经存在几个**`x-target`, 而不注重在路径上的具体位置
>
> 初始化一个`mp[0]=1`, 表示空树
> 
> `backtrack(root, sum, target)`:
> - 将`root->val`加入`sum`
> - 如果当前DFS路径上已经存在`x-target`, `ans += mp[sum-target]`
> - 记录当前路径上的前缀和, `mp[sum]++`
> - 递归左右子树
> - 递归左右子树后要取消对`sum`的计数, `mp[sum]--`

```CPP
unordered_map<long long, int> mp;   // 在当前路径上, 记录从root到cur上的pathSum出现的次数
int ans = 0;
void backtrack(TreeNode* root, long long pathSum, int targetSum){
    if(root==NULL)
        return ;
    pathSum += root->val;
    // 前缀和, 应该是pathSum - x = targetSum
    if(mp.find(pathSum-targetSum)!=mp.end())
        ans += mp[pathSum-targetSum];
    mp[pathSum]++;
    backtrack(root->left, pathSum, targetSum);
    backtrack(root->right, pathSum, targetSum);
    mp[pathSum]--;
}
int pathSum(TreeNode* root, int targetSum) {
    mp[0] = 1;
    backtrack(root, 0, targetSum);
    return ans;
}
```