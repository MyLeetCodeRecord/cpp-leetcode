#### 60. [出现频率最高的k个数字](https://leetcode.cn/problems/g5c51o/): `map`➕`priority_queue`
> `O(nlogn)`的做法是, 先统计每个数字出现的频次, 然后按频次排序(`O(nlogn)`), 或者放入`priority_queue`(大顶堆)返回堆顶的`k`个元素
> 
> `O(n)`的做法是借助`计数排序`的思想

```CPP
// priority_queue - 堆排序 - O(nlogn)
typedef pair<int, int> PII;
vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> mp;
    for(int x: nums){
        mp[x]++;
    }
    priority_queue<PII> pq;
    for(unordered_map<int, int>::iterator it=mp.begin(); it!=mp.end(); it++){
        pq.push({it->second, it->first});
    }
    vector<int> ans;
    while(k > 0 && !pq.empty()){
        ans.push_back(pq.top().second);
        pq.pop();
        k--;
    }
    return ans;
}
```

```CPP
// 计数排序 - O(n)
vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> mp;
    for(int x: nums){
        mp[x]++;
    }
    // 计数排序的思想, 出现过频次为i的有mp[i]个
    vector<int> cnt(nums.size()+1, 0);
    for(unordered_map<int, int>::iterator it=mp.begin(); it!=mp.end(); it++){
        cnt[it->second]++;
    }
    // 数前k个高频, 直到频率界限i
    int i = nums.size()+1;
    while(k > 0){       // 题目保证了"数组中前 k 个高频元素的集合是唯一的"
        k -= cnt[--i];
    }
    // 输出频率>=i的元素, 即为前k个高频元素
    vector<int> ans;
    for(unordered_map<int, int>::iterator it=mp.begin(); it!=mp.end(); it++){
        if(it->second >= i)
            ans.push_back(it->first);
    }
    return ans;
}
```