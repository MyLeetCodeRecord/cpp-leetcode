#### 位运算

##### 1. 十进制转二进制
[LC868. 二进制间距](/markdown/LC868.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D.md)

[LC2275. 按位与结果大于零的最长组合](/markdown/LC2275.%20%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%A4%A7%E4%BA%8E%E9%9B%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%84%E5%90%88.md)
> `Week293`第三题, 不连续所以用dp无法进行"状态传递"
> 
> `按位&`的性质是, 只要当前二进制位置上存在0, 则`按位与`值为0
> 
> 统计每个二进制位置上`1`出现的次数, 最高的次数即为`ans`


##### 2. 求二进制的第k位(从右往左数第k个)
> 右移`k`位, 将`num`从低位数第`k`位移到第`0`位, 然后 `(num>>k)&1`
```CPP
    // 依次求各位的二进制值(并且不实际改变num值)
    for (int k = 30; k >= 0; k--) {
        int cur = (num >> k) & 1;
        // ......
    }
```


##### 3. lowbit求最低位1

> `lowbit`的返回值是, 只保留最低位`1`的数字, 而不是最低位`1`的位置之类的

```CPP
uint32_t lowbit(uint32_t x){
    return x & (-x)
}
```
[LC191. 位1的个数](/markdown/LC191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0.md)
> 每次`lowbit(n)`保留最低位的 1
> 
> n的移动不再是n>>1, 而是**减去上一个lowbit(n)**

[LC762. 二进制表示中质数个1](/markdown/LC762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA1.md)
> 也是统计`bit=1`的位数
> 
> 判断质数只需要判断`0 ~ 32`之间的数, 因此可以提前记录下来


##### 4. (逐位)或运算记录是否出现过 (int)
> 用`int`替代`哈希数组`记录元素是否出现过, 先把元素对应到二进制的每个位上, 出现则在该位置上进行一次**或运算**
> 
> 或运算 (`|`) 的特点: 出现过`1`则会记录为`1`, 重复出现或者出现过`0`不会影响
>
> 查看某一个元素是否存在时, 只需要用`(hashInt>>k) & 1`判断即可


**[剑指offer5. 单词长度的最大乘积](/%E5%89%91%E6%8C%87offer/5.%20%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF.md)**
> 使用一个`int`(小于`1<<26`)来代指某个`word[i]`, 即每个二进制代指字母`a~z`是否出现过

```CPP
// 构建单词的二进制数字表示
vector<int> binaryWord(words.size());
for(int i=0; i<words.size(); i++){
    for(int j=0; j<words[i].size(); j++){
        char ch = words[i][j];
        binaryWord[i] |= (1<<(ch-'a'));   // | 操作逐字母构建二进制表示
    }
}
```

**[1796. 字符串中第二大的数字💚](https://leetcode.cn/problems/second-largest-digit-in-a-string/)**
> 可以用一个`int`替代长度为`10`的哈希数组记录`10`个数字是否出现过

```CPP
int secondHighest(string s) {
    int hashInt = 0;
    // 记录10个数字是否出现过
    for(char& ch : s){
        if (isdigit(ch)) 
            hashInt |= (1 << (ch - '0'));
    }
    // 找第二大的数
    int idx = 0;
    for(int k=9; k>=0; k--){
        if((hashInt >> k) & 1)
            idx++;
        if(idx==2)
            return k;
    }
    return -1;
}
```
