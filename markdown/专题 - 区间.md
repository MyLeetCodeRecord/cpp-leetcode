##### 区间问题

###### [LC435. 无重叠区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.cpp)

> 在每次选择中，选择的区间结束越早，留给后面的区间的空间越大
> 
> 因此按结束时间排序, 如果当前区间`start` >= 上一个采用区间的`end`, 则可以保留, 并更新`end`

```CPP
// 按结束时间排序 (说了八百回, 不加引用超时
bool static cmp(vector<int>& l, vector<int>& r){
    return l[1]<r[1];
}
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    int end = INT_MIN;
    int cnt = 0;
    for(int i=0; i<intervals.size(); i++){
        if(intervals[i][0] >= end){
            cnt++;
            end = intervals[i][1];
        }
    }
    return intervals.size() - cnt;
}
```

https://leetcode.cn/problems/non-overlapping-intervals/



###### [452. 用最少数量的箭引爆气球](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/workspace/452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.cpp)
> 与[LC435. 无重叠区间](https://github.com/MyLeetCodeRecord/cpp-leetcode/blob/master/markdown/%E4%B8%93%E9%A2%98%20-%20%E5%8C%BA%E9%97%B4.md#lc435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4)类似, 都是**按右端点排序**
> 
> 尽量都用points[0][1]来初始化, 而不是`INT_MIN`, 而不是0
> 
> 比如本题的测试用例`[[-2147483648,2147483647]]`, `points[0][0]==INT_MIN`
```CPP
// 按右边界排序
bool static cmp(vector<int> &l, vector<int> &r){
    return l[1] < r[1];
}
int findMinArrowShots(vector<vector<int>>& points) {
    sort(points.begin(), points.end(), cmp);
    int end = points[0][1];
    int cnt = 1;
    for(int i=0; i<points.size(); i++){
        if(points[i][0] > end){
            end = points[i][1];
            cnt++;
        }
    }
    return cnt;
}
```

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/'


###### [LC406. 根据身高重建队列]()

> 方法一: 从低到高排序, 相等则先排k小的; 每次放入前数空格位置(高度相等也计一个空格)
>
> 方法二: 先放高的, 直接放在k位置, 如果高度相同先放k小的; 维护一个queue或者vector, 借助`vi.insert(it, val)`方法插入到指定位置后

https://leetcode.cn/problems/queue-reconstruction-by-height/
