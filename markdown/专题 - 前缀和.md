#### 前缀和

##### [LC303. 区域和检索-数组不可变](/workspace/303.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.cpp)

> 标准的前缀和应用, 注意`prefixSum`要不要错开一位

```CPP
class NumArray {
private:
    vector<int> prefixSum;
public:
    NumArray(vector<int>& nums) {
        prefixSum.resize(nums.size());
        fill(prefixSum.begin(), prefixSum.end(), 0);
        prefixSum[0] = nums[0];
        for(int i=1; i<nums.size(); i++){
            prefixSum[i] = prefixSum[i-1]+nums[i];
        }
    }
    
    int sumRange(int left, int right) {
        if(right>=prefixSum.size())
            return prefixSum.back();
        if(left==0)
            return prefixSum[right];
        else
            return prefixSum[right]-prefixSum[left-1];
    }
};
```

##### [LC560. 和为K的子数组](/workspace/560.%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp)

> Keyword: `前缀和`  `map/hash`
> 
> nums[i]可能小于0, 因此不可以用`双指针`/`滑动窗口`
> 
> 初始想法: 使用`前缀和`, 接下来计算区间和(枚举<起点,终点>) => 超时
> 
> 枚举左、右两个端点超时 => 使用map记录已经出现的prefixSum[i]值
>   - 如果(左侧)已经有值为`prefixSum[i]-k`的前缀和, 如果有, 个数应为`mp[prefixSum[i]-k]`
>   - 并且对于每个`prefixSum[i]`计次, 即`mp[prefixSum[i]]++`
>   - 不会重复计数, 因为每次为`prefixSum[i]`找值为`prefixSum[i]-k`的前缀和个数时, 都保持 i 为右边界

```CPP
int subarraySum(vector<int>& nums, int k) {
    // 1. 求前缀和(错开一位也方便后面计算区间和)
    vector<int> prefixSum(nums.size()+1, 0);
    prefixSum[0] = 0;
    for(int i=1; i<=nums.size(); i++){
        prefixSum[i] = prefixSum[i-1] + nums[i-1];
    }
    // 2. map记录前缀和
    unordered_map<int, int> mp;
    int ans = 0;
    mp[0] = 1;
    for(int i=1; i<=nums.size(); i++){
        if(mp.find(prefixSum[i]-k)!=mp.end())
            ans += mp[prefixSum[i]-k];
        mp[prefixSum[i]]++;
    }
    return ans;
}
```