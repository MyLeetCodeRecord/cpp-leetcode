#### 位运算

##### 1. 十进制转二进制
###### [LC868. 二进制间距](/markdown/LC868.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D.md)
> 在十进制转二进制的基础上, 记录上一个`bit=1`出现的位置

```CPP
int binaryGap(int n) {
    int ans = 0;
    int lastOne = -1;
    int cur = 0;
    while(n != 0){
        int bit = n & 1;
        if(bit == 1){
            if(lastOne != -1)
                ans = max(ans, cur-lastOne);
            lastOne = cur;
        }
        n >>= 1;
        cur++;
    }
    return ans;
}
```
https://leetcode.cn/problems/binary-gap/


###### [LC2275. 按位与结果大于零的最长组合](/markdown/LC2275.%20%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%A4%A7%E4%BA%8E%E9%9B%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%84%E5%90%88.md)
> `Week293`第三题, 不连续所以用dp无法进行"状态传递"
> 
> `按位&`的性质是, 只要当前二进制位置上存在0, 则`按位与`值为0
> 
> 统计每个二进制位置上`1`出现的次数, 最高的次数即为`ans`

```CPP
int largestCombination(vector<int>& candidates) {
    int hash[32] = {0};
    for(int x: candidates){
        int curbit = 0;
        while(x != 0){
            hash[curbit++] += (x&1);
            x >>= 1;
        }
    }
    int ans = 1;
    for(int i=0; i<32; i++){
        ans = max(ans, hash[i]);
    }
    return ans;
}
```
https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/


##### 2. 求二进制的第k位(从右往左数第k个)
> 右移`k`位, 将`num`从低位数第`k`位移到第`0`位, 然后 `(num>>k)&1`

```CPP
// 依次求各位的二进制值(并且不实际改变num值)
for (int k = 30; k >= 0; k--) {
    int cur = (num >> k) & 1;
    // ......
}
```


##### 3. lowbit求最低位1
> `lowbit`的返回值是, 只保留最低位`1`的数字, 而不是最低位`1`的位置之类的

```CPP
uint32_t lowbit(uint32_t x){
    return x & (-x);
}
```

###### [LC191. 位1的个数](/markdown/LC191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0.md)
> 每次`lowbit(n)`保留最低位的 1
> 
> n的移动不再是n>>1, 而是**减去上一个lowbit(n)**

```CPP
uint32_t lowbit(uint32_t x) {
    return x & (-x);
}
int hammingWeight(uint32_t n) {
    int cnt = 0;
    while(n != 0){
        n -= lowbit(n);
        cnt++;
    }
    return cnt;
}
```
https://leetcode-cn.com/problems/number-of-1-bits/


###### [LC762. 二进制表示中质数个1](/markdown/LC762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA1.md)
> 也是统计`bit=1`的位数
> 
> 判断质数只需要判断`0 ~ 32`之间的数, 因此可以提前记录下来

```CPP
// 计算从1到32中的质数
vector<bool> getPrime(){
    vector<bool> prime(32, true);
    prime[0] = false;
    prime[1] = false;
    for(int x=2; x<32; x++){
        for(int i=2; i<=x/i; i++){
            if(x % i == 0)
                prime[x] = false;
        }
    }
    return prime;
}
int lowbit(int x){
    return x&(-x);
}
int countPrimeSetBits(int left, int right) {
    vector<bool> primeDict = getPrime();
    int ans = 0;
    for(int i=left; i<=right; i++){
        int x = i;
        int cnt = 0;
        while(x!=0){
            x -= lowbit(x);
            cnt++;
        }
        if(primeDict[cnt] == true)
            ans++;
    }
    return ans;
}
```
https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/


##### 4. (逐位)或运算记录是否出现过 (int)
> 当只有少量`key`, 比如26个小写字母, 可以用`int`替代`哈希数组`记录元素是否出现过, 先把元素对应到每个二进制位上(通过`1<<x`实现), 出现则在该位置上进行一次**或运算**
> 
> 或运算 (`|`) 的特点: 出现过`1`则会记录为`1`, 重复出现或者出现过`0`不会影响
>
> 查看某一个元素是否存在时, 只需要用`(hashInt>>k) & 1`判断即可


###### [LC318. 单词长度的最大乘积](/%E5%89%91%E6%8C%87offer/5.%20%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF.md)
> 使用一个`int`(小于`1<<26`)来代指某个`word[i]`, 即每个二进制代指字母`a~z`是否出现过
> 
> 对于任意两个没有公共字母的单词, 应该满足`(binaryWord[i] & binaryWord[j]) == 0`

```CPP
// 构建单词的二进制数字表示
vector<int> binaryWord(words.size());
for(int i=0; i<words.size(); i++){
    for(int j=0; j<words[i].size(); j++){
        char ch = words[i][j];
        binaryWord[i] |= (1<<(ch-'a'));   // | 操作逐字母构建二进制表示
    }
}
```
https://leetcode.cn/problems/maximum-product-of-word-lengths/


###### [1796. 字符串中第二大的数字](https://leetcode.cn/problems/second-largest-digit-in-a-string/)
> 可以用一个`int`替代长度为`10`的哈希数组记录`10`个数字是否出现过 (有点牵强...)

```CPP
int secondHighest(string s) {
    int hashInt = 0;
    // 记录10个数字是否出现过
    for(char& ch : s){
        if (isdigit(ch)) 
            hashInt |= (1 << (ch - '0'));
    }
    // 找第二大的数
    int idx = 0;
    for(int k=9; k>=0; k--){
        if((hashInt >> k) & 1)
            idx++;
        if(idx==2)
            return k;
    }
    return -1;
}
```


##### 5. 异或实现成对比较
###### [LC540. 排序数组中只出现一次的数字](/workspace/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0.cpp)
> mid是奇数 => `mid^1 = mid-1`
> 
> mid是偶数 => `mid^1 = mid+1`

```CPP
int singleNonDuplicate(vector<int>& nums) {
    int l = 0;
    int r = nums.size()-1;
    while(l < r){
        int mid = (l + r) / 2;
        // mid和mid^1来实现「成对比较」
        // - mid是奇数 => mid^1 = mid-1
        // - mid是偶数 => mid^1 = mid+1
        if(nums[mid]==nums[mid^1])
            l = mid+1;
        else
            r = mid;
    }
    return nums[l];
}
```