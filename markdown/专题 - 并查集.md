#### 并查集

##### 实现
> 实现`init`, `union_2`, `find`, `isSame`方法
> 
> - `init()`: father[i]设为i本身, 每个集合的size=1
> - `find(U)`: 一直追溯father, 直到`x==father[x]`到达最高祖先
> - `union_2(U, V)`: 将U's最高祖先的father[find(u)]设为V's最高祖先, 将sizeList[V's最早祖先]+=sizeList[U's最早祖先]
> - `isSame(U,V)`: 追溯各自的最高祖先, 如果相同则U和V处于同一个集合中

```CPP
class UnionFindSet {
    vector<int> father;
    vector<int> sizeList;
public:
    void init_us(int n){
        father.resize(n);
        sizeList.resize(n);
        for(int i=0; i<n; i++){
            father[i] = i;
            sizeList[i] = 1;
        }
    }
    int find(int u){
        return (u==father[u]) ? u : find(father[u]);
    }
    void union_2(int u, int v){
        int pu = find(u);
        int pv = find(v);
        if(pu==pv)
            return ;
        sizeList[pv] += sizeList[pu];
        father[pu] = pv;
    }
    bool isSame(int u, int v){
        return find(u)==find(v);
    }
};
```

#####

[LC2316. 统计无向图中无法互相到达点对数](/workspace/2316.%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.cpp)

> 题目描述: https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
> 
> [双周赛](/record/June-Biweek-2.md)第二题, 这题并查集会超时
> 
> TODO: 分析一下为什么并查集超时